import React, { useMemo, useState, useRef } from "react";

// ==========================
//  RUSSIA METRO-STYLE — STRICT 90°/45° SCHEMATIC (FIXED)
//  - ONLY 3 routes (Blue, Pink, Orange)
//  - Station positions are generated by relative moves (90° or 45°)
//  - All stations lie ON the path; shared segments render as PARALLEL colored lines
//  - Hubs boxed; labels never overlap
//  - Self-tests catch common config errors (length mismatch, invalid moves, shared edges exist)
//  - Fix: removed stray template-literal fragment causing "Missing semicolon"; cleaned helpers
// ==========================

type LineDef = { id: string; name: string; color: string; stations: string[] };

// Allowed moves
// L/R/U/D90 — cardinal (90°),  UL/UR/DL/DR45 — diagonals (45°)
type Move = 'L90'|'R90'|'U90'|'D90'|'UL45'|'UR45'|'DL45'|'DR45';
const GRID = 120; // base step in px
const VEC: Record<Move,[number,number]> = {
  L90:[-GRID,0], R90:[GRID,0], U90:[0,-GRID], D90:[0,GRID],
  UL45:[-GRID,-GRID], UR45:[GRID,-GRID], DL45:[-GRID,GRID], DR45:[GRID,GRID]
};

// === Routes & move sequences (exactly as requested) ===
const BLUE_STATIONS = [
  "Новосибирск","Омск","Тюмень","Екатеринбург","Набережные Челны","Казань","Чебоксары","Нижний Новгород","Владимир","Москва"
];
const BLUE_MOVES: Move[] = ['L90','UL45','L90','DL45','L90','L90','L90','L90','L90'];

const PINK_STATIONS = [
  "Новосибирск","Омск","Курган","Челябинск","Уфа","Набережные Челны","Казань","Чебоксары","Нижний Новгород","Владимир","Москва"
];
const PINK_MOVES: Move[] = ['L90','DL45','L90','L90','UL45','L90','L90','L90','L90','L90'];

const ORANGE_STATIONS = [
  "Новосибирск","Омск","Курган","Челябинск","Уфа","Тольятти"
];
const ORANGE_MOVES: Move[] = ['L90','DL45','L90','L90','DL45'];

// Northern branches (fixed per your description)
const MSK_MUR_1_STATIONS = ["Москва","Санкт-Петербург","Петрозаводск","Медвежьегорск","Мурманск"];
const MSK_MUR_1_MOVES: Move[] = ['UR45', 'U90', 'DR45', 'U90'];  // Corrected moves (4 steps)

const MSK_MUR_2_STATIONS = ["Москва","Ярославль","Вологда","Медвежьегорск","Мурманск"];
const MSK_MUR_2_MOVES: Move[] = ['DL45', 'U90', 'DR45', 'U90'];  // Corrected moves (4 steps)

// Southern branches
const MSK_KRASN_STATIONS = ["Москва","Воронеж","Ростов-на-Дону","Краснодар"];
const MSK_KRASN_MOVES: Move[] = ['D90','D90','D90'];

const MSK_MAH_1_STATIONS = ["Москва","Тамбов","Волгоград","Элиста","Будённовск","Грозный","Махачкала"];
const MSK_MAH_1_MOVES: Move[] = ['D90','D90','D90','D90','D90','D90'];

const MSK_MAH_2_STATIONS = ["Москва","Тамбов","Волгоград","Элиста","Астрахань","Махачкала"];
const MSK_MAH_2_MOVES: Move[] = ['D90','D90','D90','D90','D90'];

const LINES: LineDef[] = [
  { id: 'NSK-MSK-1', name: 'Новосибирск→Москва (через Тюмень/Екб/Челны)', color: '#1f77b4', stations: BLUE_STATIONS },
  { id: 'NSK-MSK-2', name: 'Новосибирск→Москва (через Курган/Челябинск/Уфа)', color: '#d6277b', stations: PINK_STATIONS },
  { id: 'NSK-TLT',   name: 'Новосибирск→Тольятти (через Курган/Челябинск/Уфа)', color: '#ff7f0e', stations: ORANGE_STATIONS },
  { id: 'MSK-MUR-1', name: 'Москва→Мурманск (через СПб/Петрозаводск/Медвежьег.)', color: '#2ca02c', stations: MSK_MUR_1_STATIONS },
  { id: 'MSK-MUR-2', name: 'Москва→Мурманск (через Ярославль/Вологду/Медвежьег.)', color: '#17becf', stations: MSK_MUR_2_STATIONS },
  { id: 'MSK-KRASN', name: 'Москва→Краснодар (через Воронеж/Ростов-на-Дону)', color: '#8c564b', stations: MSK_KRASN_STATIONS },
  { id: 'MSK-MAH-1', name: 'Москва→Махачкала (через Тамбов/Волгоград/Элиста/Будённовск/Грозный)', color: '#bcbd22', stations: MSK_MAH_1_STATIONS },
  { id: 'MSK-MAH-2', name: 'Москва→Махачкала (через Тамбов/Волгоград/Элиста/Астрахань)', color: '#e377c2', stations: MSK_MAH_2_STATIONS },
];

const MOVES_BY_ID: Record<string, Move[]> = {
  'NSK-MSK-1': BLUE_MOVES,
  'NSK-MSK-2': PINK_MOVES,
  'NSK-TLT':   ORANGE_MOVES,
  'MSK-MUR-1': MSK_MUR_1_MOVES,
  'MSK-MUR-2': MSK_MUR_2_MOVES,
  'MSK-KRASN': MSK_KRASN_MOVES,
  'MSK-MAH-1': MSK_MAH_1_MOVES,
  'MSK-MAH-2': MSK_MAH_2_MOVES,
};

// ===== Utilities =====
function computePositions(lines: LineDef[], moves: Record<string,Move[]>, start:{x:number;y:number}){
  const pos: Record<string,{x:number;y:number}> = {};
  const ensure = (name:string, x:number,y:number)=>{ if(!(name in pos)) pos[name] = {x,y}; return pos[name]; };

  for(const line of lines){
    const mv = moves[line.id]; if(!mv) continue;
    const st = line.stations; if(st.length<2) continue;
    // start point for this line
    const p0 = ensure(st[0], start.x, start.y);
    let cur = p0;
    for(let i=1;i<st.length;i++){
      const step = mv[i-1];
      const vec = VEC[step as Move];
      if(!vec) throw new Error(`Unknown move "${step}" in ${line.id} @${i-1}`);
      const [dx,dy] = vec;
      const next = ensure(st[i], cur.x + dx, cur.y + dy);
      cur = next;
    }
  }
  return pos;
}

// Build undirected edge list per line
function buildEdges(line: LineDef, pos: Record<string,{x:number;y:number}>){
  const out: Array<{a:string;b:string;lineId:string}> = [];
  for(let i=0;i<line.stations.length-1;i++){
    const a = line.stations[i], b = line.stations[i+1];
    if(!pos[a] || !pos[b]) continue;
    out.push({a,b,lineId: line.id});
  }
  return out;
}

function edgeKey(a:string,b:string){ return a<b? `${a}__${b}` : `${b}__${a}`; }

function unitPerp(ax:number, ay:number, bx:number, by:number){
  const dx = bx-ax, dy = by-ay; const len = Math.hypot(dx,dy) || 1;
  // perpendicular (rotate 90deg): (-dy, dx)
  return {px: -dy/len, py: dx/len};
}

// Label placement (collision-avoidant)
function estimateTextSize(text:string, fontSize=13){ const w=Math.ceil(text.length*fontSize*0.62), h=Math.ceil(fontSize*1.25); return {w,h}; }

type LabelPlacement = { x:number; y:number; anchor: 'start'|'end' };
function placeLabels(names:string[], pos:Record<string,{x:number;y:number}>, fontSize=13){
  const placed: Record<string, LabelPlacement> = {}; const rects: Array<{x:number;y:number;w:number;h:number}> = [];
  const entries = names.map(n=>[n,pos[n]] as const).sort((a,b)=>(a[1].y-b[1].y)||(a[1].x-b[1].x));
  const collide=(r:{x:number;y:number;w:number;h:number})=>rects.some(q=>!(r.x+r.w<q.x||q.x+q.w<r.x||r.y+r.h<q.y||q.y+q.h<r.y));
  const mk=(name:string,x:number,y:number,anchor:'start'|'end')=>{ const {w,h}=estimateTextSize(name,fontSize); const pad=2; const rx=anchor==='start'?x:x-w; const ry=y-h+4; return {rect:{x:rx-pad,y:ry-pad,w:w+pad*2,h:h+pad*2}}; };
  for(const [name,p] of entries){
    let chosen: LabelPlacement|undefined; const radii=[16,22,28,36,44,52,64,80,96,112,128,144,160];
    for(const d of radii){
      const cands: LabelPlacement[]=[{x:p.x+d,y:p.y-d*0.6,anchor:'start'},{x:p.x+d,y:p.y+d*0.9,anchor:'start'},{x:p.x-d,y:p.y+d*0.9,anchor:'end'},{x:p.x-d,y:p.y-d*0.6,anchor:'end'}];
      for(const c of cands){ const {rect}=mk(name,c.x,c.y,c.anchor); if(!collide(rect)){ rects.push(rect); chosen=c; break; } }
      if(chosen) break;
    }
    if(!chosen){ chosen={x:p.x+140,y:p.y+126,anchor:'start'}; const {rect}=mk(name,chosen.x,chosen.y,chosen.anchor); rects.push(rect); }
    placed[name]=chosen;
  }
  return placed;
}

// ===== Self-tests (runtime diagnostics) =====
function runSelfTests(pos: Record<string,{x:number;y:number}>){
  const messages: string[] = [];
  const errors: string[] = [];
  for(const l of LINES){
    const mv = MOVES_BY_ID[l.id];
    if(!mv){ errors.push(`Нет последовательности ходов для линии ${l.id}`); continue; }
    if(mv.length !== l.stations.length - 1){
      errors.push(`Длина moves (${mv.length}) не равна stations-1 (${l.stations.length-1}) для ${l.id}`);
    }
    mv.forEach((m,i)=>{ if(!(m in VEC)) errors.push(`Неизвестный ход "${m}" в ${l.id} @${i}`); });
    messages.push(`OK: ${l.id} — ${l.stations.length} станций, ${mv.length} ходов`);
  }

  // extra tests: проверим, что общие ребра действительно существуют и ≥2 линий их делят
  const allEdges = LINES.flatMap(l=>buildEdges(l, pos));
  const groups = new Map<string, string[]>();
  allEdges.forEach(e=>{
    const k=edgeKey(e.a,e.b);
    if(!groups.has(k)) groups.set(k,[]);
    groups.get(k)!.push(e.lineId);
  });
  const mustShare = [
    edgeKey('Новосибирск','Омск'), // все 3
    edgeKey('Набережные Челны','Казань'), // обе Нск→Мск
    edgeKey('Омск','Курган'), // розовая + оранжевая
  ];
  mustShare.forEach(k=>{
    const arr = groups.get(k)||[];
    if(arr.length<2) errors.push(`Ожидалась параллельная отрисовка для ребра ${k}, но найдено ${arr.length}`);
    else messages.push(`Shared edge ${k}: ${arr.join(', ')}`);
  });

  return {messages, errors};
}

// ===== Zoom functionality =====
const MetroMapStrict = () => {
  const [scale, setScale] = useState(1);
  const svgRef = useRef<SVGSVGElement>(null);

  const handleWheel = (event: React.WheelEvent) => {
    event.preventDefault();
    setScale(prevScale => Math.min(Math.max(0.5, prevScale + event.deltaY * -0.01), 2)); // Zoom in/out
  };

  const handleZoomIn = () => setScale(prevScale => Math.min(prevScale + 0.1, 2)); // Zoom in
  const handleZoomOut = () => setScale(prevScale => Math.max(prevScale - 0.1, 0.5)); // Zoom out

  const pos = useMemo(() => computePositions(LINES, MOVES_BY_ID, {x: 1100, y: 520}), []);
  const stations = useMemo(() => Array.from(new Set(LINES.flatMap(l => l.stations))), []);
  const labels = useMemo(() => placeLabels(stations, pos, 13), [pos]);

  // Run self-tests (after positions known)
  const { messages, errors } = runSelfTests(pos);

  return (
    <div className="w-full min-h-screen bg-white text-gray-900 p-4 space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Хаб→Хаб (строгие 90°/45°): Нск–Мск (2x) и Нск–Тольятти</h1>
        <div className="flex">
          <button onClick={handleZoomIn}>+</button>
          <button onClick={handleZoomOut}>-</button>
        </div>
      </div>

      <div className="grow border rounded-lg p-2 overflow-auto bg-white" onWheel={handleWheel}>
        <svg ref={svgRef} width={1400 * scale} height={800 * scale}>
          {/* Lines (per-edge with parallel offsets for shared segments) */}
          {(() => {
            const allEdges = LINES.flatMap(l => buildEdges(l, pos));
            const groups = new Map<string, Array<{a: string; b: string; lineId: string}>>();
            allEdges.forEach(e => {
              const k = edgeKey(e.a, e.b);
              if (!groups.has(k)) groups.set(k, []);
              groups.get(k)!.push(e);
            });
            const offsetStep = 8; // px
            const elems: JSX.Element[] = [];
            groups.forEach((arr, k) => {
              // stable order by lineId for deterministic stacking
              arr.sort((x, y) => x.lineId.localeCompare(y.lineId));
              const n = arr.length;
              arr.forEach((e, idx) => {
                const A = pos[e.a], B = pos[e.b];
                const { px, py } = unitPerp(A.x, A.y, B.x, B.y);
                const off = (idx - (n - 1) / 2) * offsetStep;
                const x1 = A.x + px * off, y1 = A.y + py * off;
                const x2 = B.x + px * off, y2 = B.y + py * off;
                const color = LINES.find(l => l.id === e.lineId)!.color;
                elems.push(<line key={`${k}_${e.lineId}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={color} strokeWidth={10} strokeLinecap="round" strokeLinejoin="round" />);
              });
            });
            return elems;
          })()}

          {/* Stations */}
          {stations.map(name => {
            const p = pos[name];
            return <circle key={name} cx={p.x} cy={p.y} r={5} fill="#111" />;
          })}

          {/* Labels + hub boxes */}
          {stations.map(name => {
            const p = pos[name];
            const lab = labels[name];
            const isHub = HUBS.has(name);
            const { w, h } = estimateTextSize(name, 13);
            return (
              <g key={name + "_lab"}>
                {isHub && (
                  <rect x={lab.anchor === 'start' ? lab.x - 4 : lab.x - w - 4} y={lab.y - h - 4} width={w + 8} height={h + 8} fill="#fff" stroke="#3b82f6" strokeWidth={1.5} rx={6} ry={6} />
                )}
                <text x={lab.x} y={lab.y} fontSize={13} textAnchor={lab.anchor} stroke="#fff" strokeWidth={3} paintOrder="stroke" fill="#111">{name}</text>
              </g>
            );
          })}
        </svg>
      </div>
    </div>
  );
};

export default MetroMapStrict;
