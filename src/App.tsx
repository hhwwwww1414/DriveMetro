import React, { useMemo, useState } from "react";

// ==========================
//  RUSSIA METRO-STYLE — STRICT 90°/45° SCHEMATIC (FIXED)
//  - ONLY 3 routes (Blue, Pink, Orange)
//  - Station positions are generated by relative moves (90° or 45°)
//  - All stations lie ON the path; shared segments render as PARALLEL colored lines
//  - Hubs boxed; labels never overlap
//  - Self-tests catch common config errors (length mismatch, invalid moves, shared edges exist)
//  - Fix: removed stray template-literal fragment causing "Missing semicolon"; cleaned helpers
// ==========================

type LineDef = { id: string; name: string; color: string; stations: string[] };

// Allowed moves
// L/R/U/D90 — cardinal (90°),  UL/UR/DL/DR45 — diagonals (45°)
type Move = 'L90'|'R90'|'U90'|'D90'|'UL45'|'UR45'|'DL45'|'DR45';
const GRID = 120; // base step in px
const VEC: Record<Move,[number,number]> = {
  L90:[-GRID,0], R90:[GRID,0], U90:[0,-GRID], D90:[0,GRID],
  UL45:[-GRID,-GRID], UR45:[GRID,-GRID], DL45:[-GRID,GRID], DR45:[GRID,GRID]
};

// === Routes & move sequences (exactly as requested) ===
const BLUE_STATIONS = [
  "Новосибирск","Омск","Тюмень","Екатеринбург","Набережные Челны","Казань","Чебоксары","Нижний Новгород","Владимир","Москва"
];
// NSK → Омск (←90) → Тюмень (↖︎45) → Екатеринбург (←90) → Набережные Челны (↘︎45) → далее всё влево до Москвы
const BLUE_MOVES: Move[] = ['L90','UL45','L90','DL45','L90','L90','L90','L90','L90'];

const PINK_STATIONS = [
  "Новосибирск","Омск","Курган","Челябинск","Уфа","Набережные Челны","Казань","Чебоксары","Нижний Новгород","Владимир","Москва"
];
// NSK → Омск (←90) → Курган (↙︎45) → Челябинск (←90) → Уфа (←90) → Н.Челны (↖︎45) → далее всё влево до Москвы
const PINK_MOVES: Move[] = ['L90','DL45','L90','L90','UL45','L90','L90','L90','L90','L90'];

const ORANGE_STATIONS = [
  "Новосибирск","Омск","Курган","Челябинск","Уфа","Тольятти"
];
// Исправлено по требованиям: через Курган → Челябинск → Уфа → Тольятти
const ORANGE_MOVES: Move[] = ['L90','DL45','L90','L90','DL45'];

const LINES: LineDef[] = [
  { id: 'NSK-MSK-1', name: 'Новосибирск→Москва (через Тюмень/Екб/Челны)', color: '#1f77b4', stations: BLUE_STATIONS },
  { id: 'NSK-MSK-2', name: 'Новосибирск→Москва (через Курган/Челябинск/Уфа)', color: '#d6277b', stations: PINK_STATIONS },
  { id: 'NSK-TLT',   name: 'Новосибирск→Тольятти (через Курган/Челябинск/Уфа)', color: '#ff7f0e', stations: ORANGE_STATIONS },
];

const MOVES_BY_ID: Record<string, Move[]> = {
  'NSK-MSK-1': BLUE_MOVES,
  'NSK-MSK-2': PINK_MOVES,
  'NSK-TLT':   ORANGE_MOVES,
};

const HUBS = new Set(["Москва","Казань","Новосибирск","Тольятти"]);

// ===== Utilities =====
function computePositions(lines: LineDef[], moves: Record<string,Move[]>, start:{x:number;y:number}){
  const pos: Record<string,{x:number;y:number}> = {};
  const ensure = (name:string, x:number,y:number)=>{ if(!(name in pos)) pos[name] = {x,y}; return pos[name]; };

  for(const line of lines){
    const mv = moves[line.id]; if(!mv) continue;
    const st = line.stations; if(st.length<2) continue;
    // start point for this line
    const p0 = ensure(st[0], start.x, start.y);
    let cur = p0;
    for(let i=1;i<st.length;i++){
      const step = mv[i-1];
      const vec = VEC[step as Move];
      if(!vec) throw new Error(`Unknown move "${step}" in ${line.id} @${i-1}`);
      const [dx,dy] = vec;
      const next = ensure(st[i], cur.x + dx, cur.y + dy);
      cur = next;
    }
  }
  return pos;
}

// Build undirected edge list per line
function buildEdges(line: LineDef, pos: Record<string,{x:number;y:number}>){
  const out: Array<{a:string;b:string;lineId:string}> = [];
  for(let i=0;i<line.stations.length-1;i++){
    const a = line.stations[i], b = line.stations[i+1];
    if(!pos[a] || !pos[b]) continue;
    out.push({a,b,lineId: line.id});
  }
  return out;
}

function edgeKey(a:string,b:string){ return a<b? `${a}__${b}` : `${b}__${a}`; }

function unitPerp(ax:number, ay:number, bx:number, by:number){
  const dx = bx-ax, dy = by-ay; const len = Math.hypot(dx,dy) || 1;
  // perpendicular (rotate 90deg): (-dy, dx)
  return {px: -dy/len, py: dx/len};
}

// Label placement (collision-avoidant)
function estimateTextSize(text:string, fontSize=13){ const w=Math.ceil(text.length*fontSize*0.62), h=Math.ceil(fontSize*1.25); return {w,h}; }

type LabelPlacement = { x:number; y:number; anchor: 'start'|'end' };
function placeLabels(names:string[], pos:Record<string,{x:number;y:number}>, fontSize=13){
  const placed: Record<string, LabelPlacement> = {}; const rects: Array<{x:number;y:number;w:number;h:number}> = [];
  const entries = names.map(n=>[n,pos[n]] as const).sort((a,b)=>(a[1].y-b[1].y)||(a[1].x-b[1].x));
  const collide=(r:{x:number;y:number;w:number;h:number})=>rects.some(q=>!(r.x+r.w<q.x||q.x+q.w<r.x||r.y+r.h<q.y||q.y+q.h<r.y));
  const mk=(name:string,x:number,y:number,anchor:'start'|'end')=>{ const {w,h}=estimateTextSize(name,fontSize); const pad=2; const rx=anchor==='start'?x:x-w; const ry=y-h+4; return {rect:{x:rx-pad,y:ry-pad,w:w+pad*2,h:h+pad*2}}; };
  for(const [name,p] of entries){
    let chosen: LabelPlacement|undefined; const radii=[16,22,28,36,44,52,64,80,96,112,128,144,160];
    for(const d of radii){
      const cands: LabelPlacement[]=[{x:p.x+d,y:p.y-d*0.6,anchor:'start'},{x:p.x+d,y:p.y+d*0.9,anchor:'start'},{x:p.x-d,y:p.y+d*0.9,anchor:'end'},{x:p.x-d,y:p.y-d*0.6,anchor:'end'}];
      for(const c of cands){ const {rect}=mk(name,c.x,c.y,c.anchor); if(!collide(rect)){ rects.push(rect); chosen=c; break; } }
      if(chosen) break;
    }
    if(!chosen){ chosen={x:p.x+140,y:p.y+126,anchor:'start'}; const {rect}=mk(name,chosen.x,chosen.y,chosen.anchor); rects.push(rect); }
    placed[name]=chosen;
  }
  return placed;
}

// ===== Self-tests (runtime diagnostics) =====
function runSelfTests(pos: Record<string,{x:number;y:number}>){
  const messages: string[] = [];
  const errors: string[] = [];
  for(const l of LINES){
    const mv = MOVES_BY_ID[l.id];
    if(!mv){ errors.push(`Нет последовательности ходов для линии ${l.id}`); continue; }
    if(mv.length !== l.stations.length - 1){
      errors.push(`Длина moves (${mv.length}) не равна stations-1 (${l.stations.length-1}) для ${l.id}`);
    }
    mv.forEach((m,i)=>{ if(!(m in VEC)) errors.push(`Неизвестный ход "${m}" в ${l.id} @${i}`); });
    messages.push(`OK: ${l.id} — ${l.stations.length} станций, ${mv.length} ходов`);
  }

  // extra tests: проверим, что общие ребра действительно существуют и ≥2 линий их делят
  const allEdges = LINES.flatMap(l=>buildEdges(l, pos));
  const groups = new Map<string, string[]>();
  allEdges.forEach(e=>{
    const k=edgeKey(e.a,e.b);
    if(!groups.has(k)) groups.set(k,[]);
    groups.get(k)!.push(e.lineId);
  });
  const mustShare = [
    edgeKey('Новосибирск','Омск'), // все 3
    edgeKey('Набережные Челны','Казань'), // обе Нск→Мск
    edgeKey('Омск','Курган'), // розовая + оранжевая
  ];
  mustShare.forEach(k=>{
    const arr = groups.get(k)||[];
    if(arr.length<2) errors.push(`Ожидалась параллельная отрисовка для ребра ${k}, но найдено ${arr.length}`);
    else messages.push(`Shared edge ${k}: ${arr.join(', ')}`);
  });

  return {messages, errors};
}

export default function MetroMapStrict(){
  const width = 1400, height = 800;

  // Canonical origin for Новосибирск
  const origin = {x: 1100, y: 520};

  const pos = useMemo(()=>computePositions(LINES, MOVES_BY_ID, origin), []);
  const stations = useMemo(()=>Array.from(new Set(LINES.flatMap(l=>l.stations))), []);
  const labels = useMemo(()=>placeLabels(stations, pos, 13), [pos]);

  // Run self-tests (after positions known)
  const {messages, errors} = runSelfTests(pos);

  return (
    <div className="w-full min-h-screen bg-white text-gray-900 p-4 space-y-4">
      <h1 className="text-2xl font-bold">Хаб→Хаб (строгие 90°/45°): Нск–Мск (2x) и Нск–Тольятти</h1>
      <p className="text-sm text-gray-600">Все узлы лежат на самих линиях. Сегменты — только ортогональные или диагональные под 45°. Общие участки рисуются параллельными линиями разного цвета.</p>

      {/* Self-test panel */}
      {errors.length>0 ? (
        <div className="p-3 border rounded bg-red-50 text-red-800 text-sm">
          <div className="font-semibold mb-1">Проблемы конфигурации:</div>
          <ul className="list-disc pl-5">
            {errors.map((e,i)=>(<li key={i}>{e}</li>))}
          </ul>
        </div>
      ) : (
        <div className="p-3 border rounded bg-emerald-50 text-emerald-800 text-sm">
          <div className="font-semibold mb-1">Самопроверка пройдена:</div>
          <ul className="list-disc pl-5">
            {messages.map((m,i)=>(<li key={i}>{m}</li>))}
          </ul>
        </div>
      )}

      <div className="grow border rounded-lg p-2 overflow-auto bg-white">
        <svg width={width} height={height}>
          {/* Lines (per-edge with parallel offsets for shared segments) */}
          {(() => {
            const allEdges = LINES.flatMap(l => buildEdges(l, pos));
            const groups = new Map<string, Array<{a:string;b:string;lineId:string}>>();
            allEdges.forEach(e=>{
              const k = edgeKey(e.a,e.b);
              if(!groups.has(k)) groups.set(k,[]);
              groups.get(k)!.push(e);
            });
            const offsetStep = 8; // px
            const elems: JSX.Element[] = [];
            groups.forEach((arr, k)=>{
              // stable order by lineId for deterministic stacking
              arr.sort((x,y)=> x.lineId.localeCompare(y.lineId));
              const n = arr.length;
              arr.forEach((e, idx)=>{
                const A = pos[e.a], B = pos[e.b];
                const {px,py} = unitPerp(A.x,A.y,B.x,B.y);
                const off = (idx - (n-1)/2) * offsetStep;
                const x1 = A.x + px*off, y1 = A.y + py*off;
                const x2 = B.x + px*off, y2 = B.y + py*off;
                const color = LINES.find(l=>l.id===e.lineId)!.color;
                elems.push(<line key={`${k}_${e.lineId}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={color} strokeWidth={10} strokeLinecap="round" strokeLinejoin="round"/>);
              });
            });
            return elems;
          })()}

          {/* Stations */}
          {stations.map(name=>{
            const p = pos[name];
            return <circle key={name} cx={p.x} cy={p.y} r={5} fill="#111" />
          })}

          {/* Labels + hub boxes */}
          {stations.map(name=>{
            const p = pos[name]; const lab = labels[name]; const isHub = HUBS.has(name); const {w,h}=estimateTextSize(name,13);
            return (
              <g key={name+"_lab"}>
                {isHub && (
                  <rect x={lab.anchor==='start'? lab.x-4 : lab.x-w-4} y={lab.y-h-4} width={w+8} height={h+8} fill="#fff" stroke="#3b82f6" strokeWidth={1.5} rx={6} ry={6} />
                )}
                <text x={lab.x} y={lab.y} fontSize={13} textAnchor={lab.anchor} stroke="#fff" strokeWidth={3} paintOrder="stroke" fill="#111">{name}</text>
              </g>
            );
          })}
        </svg>
      </div>
    </div>
  );
}
