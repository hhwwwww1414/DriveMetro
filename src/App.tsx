import React, { useMemo, useState, useRef } from "react";

// ==========================
//  RUSSIA METRO-STYLE — STRICT 90°/45° SCHEMATIC (FIXED)
//  - ONLY 3 routes (Blue, Pink, Orange)
//  - Station positions are generated by relative moves (90° or 45°)
//  - All stations lie ON the path; shared segments render as PARALLEL colored lines
//  - Hubs boxed; labels never overlap
//  - Self-tests catch common config errors (length mismatch, invalid moves, shared edges exist)
//  - Fix: removed stray template-literal fragment causing "Missing semicolon"; cleaned helpers
// ==========================

type LineDef = { id: string; name: string; color: string; stations: string[] };

// Allowed moves
// L/R/U/D90 — cardinal (90°),  UL/UR/DL/DR45 — diagonals (45°)
type Move = 'L90'|'R90'|'U90'|'D90'|'UL45'|'UR45'|'DL45'|'DR45';
const GRID = 120; // base step in px
const VEC: Record<Move,[number,number]> = {
  L90:[-GRID,0], R90:[GRID,0], U90:[0,-GRID], D90:[0,GRID],
  UL45:[-GRID,-GRID], UR45:[GRID,-GRID], DL45:[-GRID,GRID], DR45:[GRID,GRID]
};

// === Routes & move sequences (exactly as requested) ===
const BLUE_STATIONS = [
  "Новосибирск","Омск","Тюмень","Екатеринбург","Набережные Челны","Казань","Чебоксары","Нижний Новгород","Владимир","Москва"
];
const BLUE_MOVES: Move[] = ['L90','UL45','L90','DL45','L90','L90','L90','L90','L90'];

const PINK_STATIONS = [
  "Новосибирск","Омск","Курган","Челябинск","Уфа","Набережные Челны","Казань","Чебоксары","Нижний Новгород","Владимир","Москва"
];
const PINK_MOVES: Move[] = ['L90','DL45','L90','L90','UL45','L90','L90','L90','L90','L90'];

const ORANGE_STATIONS = [
  "Новосибирск","Омск","Курган","Челябинск","Уфа","Тольятти"
];
const ORANGE_MOVES: Move[] = ['L90','DL45','L90','L90','DL45'];

// Northern branches (fixed per your description)
const MSK_MUR_1_STATIONS = ["Москва","Санкт-Петербург","Петрозаводск","Медвежьегорск","Мурманск"];
const MSK_MUR_1_MOVES: Move[] = ['UR45', 'U90', 'DR45', 'U90'];  // Corrected moves (4 steps)

const MSK_MUR_2_STATIONS = ["Москва","Ярославль","Вологда","Медвежьегорск","Мурманск"];
const MSK_MUR_2_MOVES: Move[] = ['DL45', 'U90', 'DR45', 'U90'];  // Corrected moves (4 steps)

// Southern branches
const MSK_KRASN_STATIONS = ["Москва","Воронеж","Ростов-на-Дону","Краснодар"];
const MSK_KRASN_MOVES: Move[] = ['D90','D90','D90'];

const MSK_MAH_1_STATIONS = ["Москва","Тамбов","Волгоград","Элиста","Будённовск","Грозный","Махачкала"];
const MSK_MAH_1_MOVES: Move[] = ['D90','D90','D90','D90','D90','D90'];

const MSK_MAH_2_STATIONS = ["Москва","Тамбов","Волгоград","Элиста","Астрахань","Махачкала"];
const MSK_MAH_2_MOVES: Move[] = ['D90','D90','D90','D90','D90'];

const LINES: LineDef[] = [
  { id: 'NSK-MSK-1', name: 'Новосибирск→Москва (через Тюмень/Екб/Челны)', color: '#1f77b4', stations: BLUE_STATIONS },
  { id: 'NSK-MSK-2', name: 'Новосибирск→Москва (через Курган/Челябинск/Уфа)', color: '#d6277b', stations: PINK_STATIONS },
  { id: 'NSK-TLT',   name: 'Новосибирск→Тольятти (через Курган/Челябинск/Уфа)', color: '#ff7f0e', stations: ORANGE_STATIONS },
  { id: 'MSK-MUR-1', name: 'Москва→Мурманск (через СПб/Петрозаводск/Медвежьег.)', color: '#2ca02c', stations: MSK_MUR_1_STATIONS },
  { id: 'MSK-MUR-2', name: 'Москва→Мурманск (через Ярославль/Вологду/Медвежьег.)', color: '#17becf', stations: MSK_MUR_2_STATIONS },
  { id: 'MSK-KRASN', name: 'Москва→Краснодар (через Воронеж/Ростов-на-Дону)', color: '#8c564b', stations: MSK_KRASN_STATIONS },
  { id: 'MSK-MAH-1', name: 'Москва→Махачкала (через Тамбов/Волгоград/Элиста/Будённовск/Грозный)', color: '#bcbd22', stations: MSK_MAH_1_STATIONS },
  { id: 'MSK-MAH-2', name: 'Москва→Махачкала (через Тамбов/Волгоград/Элиста/Астрахань)', color: '#e377c2', stations: MSK_MAH_2_STATIONS },
];

const MOVES_BY_ID: Record<string, Move[]> = {
  'NSK-MSK-1': BLUE_MOVES,
  'NSK-MSK-2': PINK_MOVES,
  'NSK-TLT':   ORANGE_MOVES,
  'MSK-MUR-1': MSK_MUR_1_MOVES,
  'MSK-MUR-2': MSK_MUR_2_MOVES,
  'MSK-KRASN': MSK_KRASN_MOVES,
  'MSK-MAH-1': MSK_MAH_1_MOVES,
  'MSK-MAH-2': MSK_MAH_2_MOVES,
};

// ===== Utilities for pan and zoom =====
const MetroMapStrict = () => {
  const [scale, setScale] = useState(1);
  const svgRef = useRef<SVGSVGElement>(null);

  const handleWheel = (event: React.WheelEvent) => {
    event.preventDefault();
    setScale(prevScale => Math.min(Math.max(0.5, prevScale + event.deltaY * -0.01), 2)); // Zoom in/out
  };

  const handleZoomIn = () => setScale(prevScale => Math.min(prevScale + 0.1, 2)); // Zoom in
  const handleZoomOut = () => setScale(prevScale => Math.max(prevScale - 0.1, 0.5)); // Zoom out

  return (
    <div className="w-full min-h-screen bg-white text-gray-900 p-4 space-y-4">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Хаб→Хаб (строгие 90°/45°): Нск–Мск (2x) и Нск–Тольятти</h1>
        <div className="flex">
          <button onClick={handleZoomIn}>+</button>
          <button onClick={handleZoomOut}>-</button>
        </div>
      </div>

      <div className="grow border rounded-lg p-2 overflow-auto bg-white" onWheel={handleWheel}>
        <svg ref={svgRef} width={1400 * scale} height={800 * scale}>
          {/* Lines (per-edge with parallel offsets for shared segments) */}
          {(() => {
            const allEdges = LINES.flatMap(l => buildEdges(l, pos));
            const groups = new Map<string, Array<{a:string;b:string;lineId:string}>>();
            allEdges.forEach(e=>{
              const k = edgeKey(e.a,e.b);
              if(!groups.has(k)) groups.set(k,[]);
              groups.get(k)!.push(e);
            });
            const offsetStep = 8; // px
            const elems: JSX.Element[] = [];
            groups.forEach((arr, k)=>{
              // stable order by lineId for deterministic stacking
              arr.sort((x,y)=> x.lineId.localeCompare(y.lineId));
              const n = arr.length;
              arr.forEach((e, idx)=>{
                const A = pos[e.a], B = pos[e.b];
                const {px,py} = unitPerp(A.x,A.y,B.x,B.y);
                const off = (idx - (n-1)/2) * offsetStep;
                const x1 = A.x + px*off, y1 = A.y + py*off;
                const x2 = B.x + px*off, y2 = B.y + py*off;
                const color = LINES.find(l=>l.id===e.lineId)!.color;
                elems.push(<line key={`${k}_${e.lineId}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={color} strokeWidth={10} strokeLinecap="round" strokeLinejoin="round"/>);
              });
            });
            return elems;
          })()}

          {/* Stations */}
          {stations.map(name=>{
            const p = pos[name];
            return <circle key={name} cx={p.x} cy={p.y} r={5} fill="#111" />
          })}

          {/* Labels + hub boxes */}
          {stations.map(name=>{
            const p = pos[name]; const lab = labels[name]; const isHub = HUBS.has(name); const {w,h}=estimateTextSize(name,13);
            return (
              <g key={name+"_lab"}>
                {isHub && (
                  <rect x={lab.anchor==='start'? lab.x-4 : lab.x-w-4} y={lab.y-h-4} width={w+8} height={h+8} fill="#fff" stroke="#3b82f6" strokeWidth={1.5} rx={6} ry={6} />
                )}
                <text x={lab.x} y={lab.y} fontSize={13} textAnchor={lab.anchor} stroke="#fff" strokeWidth={3} paintOrder="stroke" fill="#111">{name}</text>
              </g>
            );
          })}
        </svg>
      </div>
    </div>
  );
}

export default MetroMapStrict;
